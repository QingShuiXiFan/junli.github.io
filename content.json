{"meta":{"title":"Jun Li's Blog","subtitle":"","description":"","author":"Jun Li","url":"http://qingshuixifan.github.io","root":"/"},"pages":[{"title":"Categories","date":"2020-11-11T06:30:16.779Z","updated":"2020-11-11T06:30:16.779Z","comments":false,"path":"categories/index.html","permalink":"http://qingshuixifan.github.io/categories/index.html","excerpt":"","text":""},{"title":"404 Not Found：Unable to show this page","date":"2020-11-11T14:19:19.518Z","updated":"2020-11-11T14:19:19.518Z","comments":false,"path":"/404.html","permalink":"http://qingshuixifan.github.io/404.html","excerpt":"","text":""},{"title":"Friend Links","date":"2020-11-12T03:03:12.312Z","updated":"2020-11-12T03:03:12.312Z","comments":true,"path":"links/index.html","permalink":"http://qingshuixifan.github.io/links/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-11-11T13:54:02.499Z","updated":"2020-11-11T13:54:02.499Z","comments":false,"path":"tags/index.html","permalink":"http://qingshuixifan.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-11-11T06:15:21.636Z","updated":"2019-08-02T02:17:12.000Z","comments":false,"path":"repository/index.html","permalink":"http://qingshuixifan.github.io/repository/index.html","excerpt":"","text":""},{"title":"Book list","date":"2020-11-11T06:17:29.806Z","updated":"2020-11-11T06:17:29.806Z","comments":false,"path":"books/index.html","permalink":"http://qingshuixifan.github.io/books/index.html","excerpt":"","text":""},{"title":"About","date":"2020-11-16T03:49:11.233Z","updated":"2020-11-16T03:49:11.233Z","comments":false,"path":"about/index.html","permalink":"http://qingshuixifan.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"【Algorithm】Binary Search","slug":"【Algorithm】Binary Search","date":"2020-11-13T10:09:28.961Z","updated":"2020-11-13T10:13:47.432Z","comments":true,"path":"2020/11/13/【Algorithm】Binary Search/","link":"","permalink":"http://qingshuixifan.github.io/2020/11/13/%E3%80%90Algorithm%E3%80%91Binary%20Search/","excerpt":"","text":"Applicable Scenarios Search a certain number in a ** sorted ** array, under some condition. Code Snippets1234567891011121314# Recursivedef bsearch(nums: list, low: int, high: int, value) -&gt; int: &quot;&quot;&quot; 在数组nums的下标low和high之间，查找value，返回下标 &quot;&quot;&quot; if low &gt; high: return -1 middle = low + (high - low) &gt;&gt; 1 if nums[middle] == value: # 找到了 return middle elif nums[middle] &gt; value: return bsearch(nums, low, middle-1, value) # high = middle-1 else: return bsearch(nums, middle+1, high, value) # low = middle+1 12345678910111213# Iterativedef bsearch(nums: List[int], target: int) -&gt; int: left= 0 right=len(nums) - 1 while left &lt;= right: # 区间没有变成1个元素，就查找 middle = left + ((right-left) &gt;&gt; 1) # 计算中间下标 if nums[middle] == target: # 找到了 return middle elif nums[middle] &lt; target: # 中间下标比查找的值小，继续在右边查找 left = middle + 1 else: # 中间下标比查找的值大，继续在左边查找 right = middle - 1 return -1","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://qingshuixifan.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://qingshuixifan.github.io/tags/Algorithm/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://qingshuixifan.github.io/tags/Binary-Search/"},{"name":"EN","slug":"EN","permalink":"http://qingshuixifan.github.io/tags/EN/"}]},{"title":"【Git】Git Cheatsheet","slug":"【Git】Git Cheatsheet","date":"2020-11-12T08:07:21.219Z","updated":"2020-11-12T08:23:02.978Z","comments":true,"path":"2020/11/12/【Git】Git Cheatsheet/","link":"","permalink":"http://qingshuixifan.github.io/2020/11/12/%E3%80%90Git%E3%80%91Git%20Cheatsheet/","excerpt":"","text":"","categories":[{"name":"IT","slug":"IT","permalink":"http://qingshuixifan.github.io/categories/IT/"}],"tags":[{"name":"EN","slug":"EN","permalink":"http://qingshuixifan.github.io/tags/EN/"},{"name":"Git","slug":"Git","permalink":"http://qingshuixifan.github.io/tags/Git/"}]},{"title":"【Data Structure】Union-find data structure","slug":"【Data Structure】Union-find data structure","date":"2020-11-12T08:01:03.264Z","updated":"2020-11-12T08:06:53.792Z","comments":true,"path":"2020/11/12/【Data Structure】Union-find data structure/","link":"","permalink":"http://qingshuixifan.github.io/2020/11/12/%E3%80%90Data%20Structure%E3%80%91Union-find%20data%20structure/","excerpt":"","text":"Definition A disjoint-set data structure (also called union-find data structure) is a data structure that tracks a set of elements partitioned into a number of disjoint (overlapping) subsets. Operations Union: Add new sets/merge existing sets Find: Determine whether elements are in the same set Algorithm The representative element (one without a parent, or whose parent is itself) is used to represent a subset All the elements in a subset compose a tree structure whose root is representative element if an element has a parent, the element is part of whatever set is identified by following the chain of parents upwards until a representative element is reached at the root of the tree If the representative element of the two elements is the same, then they belong to the same subset Code Snippets Initialization Use a struct or class1234567#define MAX 10000struct Node&#123; int data; int rank; int parent;&#125;node[MAX] Use arrays of the same size12345678int set[max]; // the representative element of a subset where the certain element inint rank[max];int data[max];void makeSet(int i)&#123; set[I]=i; rank[i]=0;&#125; Find Function struct or class12345678// find the representative element of a subset recursivelyint find(int x)&#123; // if a node&#x27;s parent is itself, then it is the representative element if(node[x].parent==x) return x; // else recursively find its parent return find(node[x].parent)&#125; array1234567int find(int i)&#123; // if a node&#x27;s parent is itself, then it is the representative element if(set[i]==i) return set[i]; // else recursively find its parent return find(set[i])&#125; Union struct or class1234567891011void union(int a, int b)&#123; a=find(a); b=find(b); if(node[a].rank&gt;node[b].rank) node[b].parent=a; else&#123; node[a].parent=b; if(node[a].rank==node[b].rank) node[b].rank++; &#125;&#125; array1234567891011void union(int I, int j)&#123; I=find(I); j=find(j); if(i==j) return ; if(rank[i]&gt;rank[j]) set[j]=i; else&#123; if(rank[i]==rank[j]) rank[j]++; set[i]=j; &#125;&#125; Related Problems Compute the number of disjoint subsets -&gt; count the number of nodes whose parent is itself, i.e. parent[i]==i Leetcode 990 - Satisfiability of Equality Equations","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://qingshuixifan.github.io/categories/Data-Structure/"}],"tags":[{"name":"EN","slug":"EN","permalink":"http://qingshuixifan.github.io/tags/EN/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://qingshuixifan.github.io/tags/Data-Structure/"},{"name":"Union-find","slug":"Union-find","permalink":"http://qingshuixifan.github.io/tags/Union-find/"}]},{"title":"【Markdown】Typora导出pdf分页的两种方法","slug":"【Markdown】Typora导出pdf分页","date":"2020-11-11T13:54:36.767Z","updated":"2020-11-12T07:44:06.693Z","comments":true,"path":"2020/11/11/【Markdown】Typora导出pdf分页/","link":"","permalink":"http://qingshuixifan.github.io/2020/11/11/%E3%80%90Markdown%E3%80%91Typora%E5%AF%BC%E5%87%BApdf%E5%88%86%E9%A1%B5/","excerpt":"","text":"自动分页符有时您可能需要导出为PDF，并在顶层标题上使用分页符。 打开主题文件夹，然后编辑要包含的主题的css 12345678@media print &#123; h1 &#123; page-break-before: always; &#125; h1:first-of-type &#123; page-break-before: avoid; &#125;&#125; 现在，在导出时，将在每个h1元素（第一个元素除外）之前创建一个新页面。 强制分页符（方便）要在文档上插入分页&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;符，可以在书写时尝试输入HTML 。","categories":[{"name":"IT","slug":"IT","permalink":"http://qingshuixifan.github.io/categories/IT/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://qingshuixifan.github.io/tags/Markdown/"},{"name":"CN","slug":"CN","permalink":"http://qingshuixifan.github.io/tags/CN/"}]},{"title":"【Git】How to clone from GitHub faster in China","slug":"【Git】How to clone from GitHub faster in China","date":"2020-11-11T09:38:33.247Z","updated":"2020-11-12T02:54:28.382Z","comments":true,"path":"2020/11/11/【Git】How to clone from GitHub faster in China/","link":"","permalink":"http://qingshuixifan.github.io/2020/11/11/%E3%80%90Git%E3%80%91How%20to%20clone%20from%20GitHub%20faster%20in%20China/","excerpt":"","text":"Sometimes it’s bloody slow to clone a repository from GitHub in China mainland, so follow the following way to clone the repos from GitHub Chinese mirror site: Steps: Just replace www.github.com with www.github.com.cnpmjs.org, like the following example: 1git clone https://github.com.cnpmjs.org/QingShuiXiFan/mysite.git","categories":[{"name":"IT","slug":"IT","permalink":"http://qingshuixifan.github.io/categories/IT/"}],"tags":[{"name":"EN","slug":"EN","permalink":"http://qingshuixifan.github.io/tags/EN/"},{"name":"Git","slug":"Git","permalink":"http://qingshuixifan.github.io/tags/Git/"}]}],"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://qingshuixifan.github.io/categories/Algorithm/"},{"name":"IT","slug":"IT","permalink":"http://qingshuixifan.github.io/categories/IT/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://qingshuixifan.github.io/categories/Data-Structure/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://qingshuixifan.github.io/tags/Algorithm/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://qingshuixifan.github.io/tags/Binary-Search/"},{"name":"EN","slug":"EN","permalink":"http://qingshuixifan.github.io/tags/EN/"},{"name":"Git","slug":"Git","permalink":"http://qingshuixifan.github.io/tags/Git/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://qingshuixifan.github.io/tags/Data-Structure/"},{"name":"Union-find","slug":"Union-find","permalink":"http://qingshuixifan.github.io/tags/Union-find/"},{"name":"Markdown","slug":"Markdown","permalink":"http://qingshuixifan.github.io/tags/Markdown/"},{"name":"CN","slug":"CN","permalink":"http://qingshuixifan.github.io/tags/CN/"}]}